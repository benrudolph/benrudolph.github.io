--- 
layout: post
title: How to finish
tags: []

status: publish
type: post
published: true
meta: 
  email_notification: "1357351096"
  jabber_published: "1357351095"
  _publicize_pending: "1"
  _edit_last: "27826612"
---
Starting a software project is not so bad. Building out the meat of your application is fun. However, mustering up the courage, fortitude and finger-typing-muscles to finish it is a whole other beast. I can attest to this as I have over 40 repositories in my projects folder alone. Only a handful are finished, but through my time wallowing in half-baked software projects, I've gotten much better at typing that final semicolon. Here are some of the strategies that've helped me.

<strong>Know what you're doing</strong>

This sounds simple, yet this seems to be the most common cause of death for my software creations. My old thought process would be to think of some cool idea, say gesture recognizing glasses. Then, immediately start coding and realize later that there is no way I'd be able to finish such a project. I don't have a small video camera to sit atop my glasses, nor do I have a super powerful microcontroller to process real-time video. Granted, these things can be bought, but it sure takes the wind out of those sails.

In order to actually figure out what I'm doing, I like to take an idea I have and flesh out some of its parts. Usually this involves pencil and paper and drawing what the application will do or how it will function. Sometimes I'll go so far as to write a small design document briefly describing the technologies I'll use and what I think the toughest parts will be. Any system will do, just find something that works for you so that you have a big picture of how your project will turn out.

<strong>Rewards</strong>

Building out a complete project often has loads of fun and interesting aspects, but there are always, always the dreaded parts that are necessary to finish the application (usually those darn tests). To knock out these more painful steps, I setup a reward system for myself. If I finish something mundane like error handling (my software doesn't have bugs, right?), then I'll reward myself with something cool like animating a graph. Or if there just isn't anything fun left to do, I'll eat my feelings and pull out a bag of sugar coated almonds. Probably not the healthiest way to code.

<strong>Version control</strong>

Version control didn't initially strike me as a tool to boost me to finish the line. Sure, it'll save you in an event of crisis, and it definitely keeps the morale up when you go charging down the wrong path only to realize you have to undo your work. But there is something much more subtle about version control that enables me to finish projects, and that is the power of incremental steps. Breaking your project down into small commit-sized bites makes it easier to swallow a large task.

It's also important to actually breakdown your commits into logical chunks of progress. For me at least, it never feels quite right when I write a commit message outlining 4-5 half finished features. I yearn for that good wholesome <code>git commit</code> where I've completed a solid feature like "Added search functionality to message model." I mean, who doesn't?

<strong>The List</strong>

This one is simple but effective. Every time I start a project now I always start a TODO list to keep track of things I need to finish in the near future. It's enough to just put down four or five items that I'm working on currently; it doesn't have to be an exhaustive list. The evolution of the TODO list is pretty interesting as well, as I watch the list of features that need to be completed be turned into a list of bugs I need to fix.

---

Alas, there is no end-all-be-all method to completing every project. Sometimes it just takes a little bit of focus and determination to get 'er done. No doubt there will be a few stranded, empty repositories in that projects folder, but I've found that it's much better to have a few completed projects than loads of broken applications.
