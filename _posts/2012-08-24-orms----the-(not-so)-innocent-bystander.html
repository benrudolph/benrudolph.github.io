--- 
layout: post
title: ORMs -- the (not-so) innocent bystander
tags: []

status: draft
type: post
published: false
meta: 
  _edit_last: "27826612"
---
I've used ORMs (Object Relational Models?) pretty ubiquitously throughout my time coding web apps. Some that I've used are Sequel, Active Record and Django's query language. I've grown to love them -- especially after having to write real SQL queries after using them. But, the other day, these little, fluffy ORMs caused me a big deal of trouble. And you too could be experiencing the nasty underside of the ORM.

The problem that I ran into was that these query languages were <strong>too easy</strong> to use. Why it's merely like calling a class method! Let's look at a quick example to feel the full effect.
<pre>class Library(Sequel::Model)

end
class Book(Sequel::Model)
  many_to_one :library

  def public_model
    page_length = self.page_length
    available = self.is_available
  end
end</pre>
Contrived? Yes. Uncommon? No! This kind of stuff can happen unknowingly all over the place. Now, all of a sudden when you try and get the public model for that book you have to do a &lt;code&gt;SELECT * FROM libraries WHERE (id = 25)&lt;/code&gt;. OK, so what? Well, this actually doesn't really matter until you decide that you want to get the public model for every book in that library. Then, wham bam, you got yourself N number of &lt;code&gt;SELECT * FROM libraries WHERE (id = 25)&lt;/code&gt; statements.

I found this optimization bug in some code I was working on recently. It was so bad that I was profiling by counting the number of seconds that went by when I hit a tab.
